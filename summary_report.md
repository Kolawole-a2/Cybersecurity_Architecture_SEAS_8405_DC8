
# deliverables/summary_report.md

This project undertook a comprehensive evaluation and hardening of container security configurations within a Docker-based development environment. The primary objective was implementing security best practices by enhancing key components that influence container behavior and host interaction. Different vulnerabilities were identified and fixed in this Docker hardening script. Firstly, it was observed that the containers were running as root. Thus, it means the Docker files often run apps as root by default. The consequence of this is that if the vulnerability is exploited, the attacker gets root access inside the container and they can modify anything at will. The fix that was subsequently made for this is adding a non-root user (i.e. Appuser)and setting it to use the USER instruction. This fix will restrict the user access to a limited level within the system environment, and they will not be able to change the system without the necessary permissions. Another thing is the absence of Health Checks in the Docker file. There is no way to automatically detect and restart failed apps in the environment. Based on this, the Apps could silently fail and keep running without being noticed. The fix in the hardening code for this was an added Healthcheck, which pings the app's local endpoint.

Insecure Docker Daemon Configuration was also detected and fixed in the given code. The daemon.json may allow features like inter-container communication, which tends to expose the system. With this, the containers can talk to each other even when they are not supposed to do that. The fix in our hardened code that handled this was the disabled inter-container communication (icc) and enabled userns-remap, live-restore, and also, the disabled userland-proxy which perfectly corrected the vulnerable Docker Daemon Configuration. An overly broad network exposure was another vulnerability corrected in our given code. In the initial system, the Docker services were exposed to the whole world (0.0.0.0) and this increased the risk of external attacks. In our fixing code, this was corrected by replacing the IP: 0.0.0.0 with 127.0.0.1, so services are local only. It was also discovered that there was no container resource limits and the containers could use unlimited memory and processes. This opens up the system to DoS (Denial of Service). Thus, this vulnerability was fixed by adding memory limit (512m), process limit (pids_limit), and set the container to read-only. 
Having mentioned the above, it could also be noticed that no 'security_opt' settings was configured in the container and containers could gain extra privileges. Owing to this, attackers might escape from containers or even escalate privileges. Consequently in the fixing code, this was rectified by enforced 'no-new-privileges:true' which helps to block privilege escalations. 

The redesigned system architecture was deliberately structured to strengthen container security without sacrificing functionality. By limiting unnecessary communications, enforcing constraints on processes and memory usage, and eliminating the need for privileged execution, the configuration aligns more closely with key security principles such as least privilege and defense-in-depth. These measures help to strictly contain each container’s behavior and access, effectively narrowing their operational boundaries. Additional safeguards like runtime health checks and isolation from host system resources contribute to improved system resilience. Restricting port bindings to the local interface further reduces the system’s exposure to external threats. Together, these enhancements transform a previously open container environment into a more disciplined and secure one by improving both reliability and resistance to attacks. This approach illustrates how thoughtful planning and secure configuration practices can significantly elevate the overall security of containerized systems.

Participating in this security hardening effort has offered several key takeaways, particularly regarding the secure management of container environments. One major insight is the value of managing infrastructure through code. This approach promotes uniformity across environments and enables scalable, repeatable security measures. The project also shed light on the limitations of Docker’s default settings, which often prioritize ease of use over safety. By embedding best practices directly into deployment pipelines, the likelihood of configuration errors is reduced, and security becomes an integral part of system development. Perhaps most importantly, the experience emphasized the need for a proactive security approach that anticipates potential threats and designs systems to resist them from the outset. The use of automated tools to apply security controls demonstrates the importance of integrating protection mechanisms into the early stages of the development process. In conclusion, this project reinforced that security should be foundational, not an afterthought, in any modern system architecture.







